---
title: AQS
date: 2022-04-04 10:03:10
permalink: /pages/b7d0da/
categories:
  - 技术文章
  - Java
  - JUC
---
## 前言

### 并发问题引入

```java
@Controller
public class TradeController {
    @Autowired
    private TradeService tradeService;

    @RequestMapping("/order")
    public String order() {
        tradeService.decStock();
        return "success";
    }
}

@Service
public class TradeService {
    Logger logger = Logger.getLogger(TradeService.class);
    @Autowired
    JdbcTemplate jdbcTemplate;
    /**
     * 扣减库存
     * @return
     */
    public String decStock() {
        Integer stock = jdbcTemplate.queryForObject("select stock from goods_stock where id = 1", Integer.class);
        if (stock <= 0) {
            logger.info("库存不足，下单失败！");
            return "库存不足，下单失败！";
        }
        stock--;
        jdbcTemplate.update("update goods_stock set stock = ? where id = 1", stock);
        logger.info("下单成功，当前剩余库存：" + stock);
        return "下单成功，当前剩余库存：" + stock;
    }
}
```

如上代码，数据库中初始库存设置为10，用Jmeter模拟30个请求同时下单，结果30个请求都下单成功，产生了超卖问题。这里当然可以采用在方法里加synchronized，实现并发安全。这里我们采用自定义AQS解决：

### 自定义AQS解决

```java
/**
 * 2021/7/1
 * 自定义AQS实现
 */
public class MyLock {

    private volatile int state = 0;

    private Thread lockHolder;

    // 要用线程安全的队列作为等待队列,基于CAS实现
    private ConcurrentLinkedDeque<Thread> waiters = new ConcurrentLinkedDeque<>();

    public int getState() {
        return state;
    }
    public void setState(int state) {
        this.state = state;
    }
    public Thread getLockHolder() {
        return lockHolder;
    }
    public void setLockHolder(Thread lockHolder) {
        this.lockHolder = lockHolder;
    }

    public void lock() {
        Thread currentThread = Thread.currentThread();
        if (acquire()) {
            return;
        }
        waiters.add(currentThread);
        // 自旋
        for (; ; ) {
            // 队列里第一个线程才能抢锁
            if (currentThread == waiters.peek() && acquire()) {
                // 队列头线程拿到锁 踢出等待队列
                waiters.poll();
                return;
            }
            // 阻塞当前线程 放弃CPU使用权
            LockSupport.park();
        }
    }

    public void unLock() {
        if (Thread.currentThread() != lockHolder) {
            throw new RuntimeException("lockHolder is not current thread");
        }
        if (compareAndSwapState(getState(), 0)) {
            setLockHolder(null);
            // 唤醒队列里第一个线程
            Thread first = waiters.peek();
            if (first != null) {
                LockSupport.unpark(first);
            }
        }
    }

    // 是否能加锁成功
    private boolean acquire() {
        Thread currentThread = Thread.currentThread();
        if (getState() == 0) { // 同步器尚未被持有
            // 没人排队/自己是队列头，才能去尝试原子操作改变state
            if ((waiters.size() == 0 || currentThread == waiters.peek()) && compareAndSwapState(0, 1)) {
                setLockHolder(currentThread);
                return true;
            }
        }
        return false;
    }


    // 利用Unsafe类实现原子操作改变值
    public final boolean compareAndSwapState(int expect, int update) {
        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
    }

    private static final Unsafe unsafe = reflectGetUnsafe();
    // 偏移量
    private static final long stateOffset;

    static {
        try {
            stateOffset = unsafe.objectFieldOffset(MyLock.class.getDeclaredField("state"));
        } catch (Exception e) {
            throw new Error();
        }
    }

    // 反射获取Unsafe类
    private static Unsafe reflectGetUnsafe() {
        try {
            Field field = Unsafe.class.getDeclaredField("theUnsafe");
            field.setAccessible(true);
            return (Unsafe) field.get(null);
        } catch (Exception e) {
            return null;
        }
    }
}
```

```java
public class TradeService {
    Logger logger = Logger.getLogger(TradeService.class);
    @Autowired
    JdbcTemplate jdbcTemplate;
    // 单例 创建锁对象
    MyLock myLock = new MyLock();
    public String decStock() {
        myLock.lock();	// 加锁
        Integer stock = jdbcTemplate.queryForObject("select stock from goods_stock where id = 1", Integer.class);
        if (stock <= 0) {
            logger.info("库存不足，下单失败！");
            myLock.unLock();	// 业务失败 释放锁
            return "库存不足，下单失败！";
        }
        stock--;
        jdbcTemplate.update("update goods_stock set stock = ? where id = 1", stock);
        logger.info("下单成功，当前剩余库存：" + stock);
        myLock.unLock();	// 业务成功 释放锁
        return "下单成功，当前剩余库存：" + stock;
    }
}
```



## 概述

> 抽象同步框架，可以用来实现一个**依赖状态**的同步器https://www.cnblogs.com/waterystone/p/4920797.html

1.可以实现独占与共享两种模式：

- 独占：互斥，资源只能同时被一个线程占有
- 共享：资源不互斥，可以被多个线程占有，实现有读锁
  - 共享：Semaphre，可以指定初始的state，允许同时多个线程获取锁

2.核心属性：

- state：同步器的状态
- exclusiveOwnerThread：当前持有互斥锁的线程

- head：同步队列头
- tail：同步队列尾

3.特性：

- 可中断
- 可重入





